## DFS 

Depth-Fisrt Search(DFS)는 깊이 우선 탐색이라고도 불리며 그래프에서 깊은 부분을 우선적으로 탐색한다. 

## Content

- [Graph 구현법](#Graph)
- [DFS 란?](#DFS)

## Graph

그래프는 크게 가지 방법으로 구현된다. 

- 인접 행렬(Adjacency Matrix) 방식

    2차원 배열로 그래프의 연결 관계를 표현

    그래프를 정의해서 각 노드가 각 column과 row의 요소가 된다. 자기 자신과의 연결은 고려하지 않을 때 0으로 표현되며 연결 되어 있지 않은 노드 끼리는 무한비용(INF)으로 표기 된다. 무한비용은 실제 코드상에서는 정답이 될 수 없는 큰 값중에서 9999999999 등의 값으로 초기화 한다. 

```python

INF = 99999999 # 무한 비용 

# Adjacency Matrix
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]
```

|Adjacency Matrix|**0**|**1**|**2**|
|:------:|:---:|:---:|:---:|
|**0**|0|7|5|
|**1**|7|0|INF|
|**2**|5|INF|0|

그리고 당연히 Adjacency Matrix는 Sysymmetric Matrix가 된다. 


- 인접 리스트(Adjacency List)

    리스트로 그래프의 연결 관계를 표현

    각 노드 별로 연결 되어 있는 노드의 정보를 리스트 형태로 저장한다. 

    C++이나 자바에서는 연결 리스트를 통해 구현되나 파이썬에서는 기본 list 에서 append나 pop 연산을 지원하기 때문에 그냥 리스트로 구현하면 된다. 

```python
# 노드 개수 만큼 리스트 생성 
num_node = 3
graph = [[] for _ in range(num_nude)]

# 0번 노드에 연결 정보 저장 (노드, 거리)
graph[0].append((1,7))
graph[0].append((2,5))

# 1번 노드에 연결 정보 저장 (노드, 거리)
graph[1].append((0, 7))

# 2번 노드에 연결 정보 저장 (노드, 거리)
graph[2].append((0, 5))
```
|Adjacency Matrix|**0**|**1**|**2**|
|:------:|:---:|:---:|:---:|
|**0**|0|7|5|
|**1**|7|0|INF|
|**2**|5|INF|0|


구현 별 장/단점

1. Matrix 방식 

장점 : 어떤 노드와 어떤 노드 간 연결 정보 조회 속도가 빠름 

단점 : 모든 연결 정보를 저장해야함(메모리 소모)

2. List 방식 

장점 : 연결 정보만 저장, 때문에 메모리 소모 적음 

단점 : 어떤 노드와 어떤 노드 연결 여부 확인시 한 노드의 리스트를 처음부터 해당 노드가 나올때 까지 조회해야함, 속도 떨어짐


## DFS 

DFS 는 깊이 우선 탐색 알고리즘으로 깊이를 우선시 하여 탐색한다. 하나의 경로를 끝 까지 간 뒤에 다른 경로를 확인한다. 

스택에 방문했던 노드 정보를 저장하는 방식으로 구현된다. 

- 탐색 시작 노드를 스택에 삼입하고 방문 처리를 한다. 

- 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다. 

- 위 과정을 더이상 수행 할 수 없을 때 까지 수행.

방문 처리는 스택에 한번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는것을 의미한다. 

스택을 쓰는 이유는 **현재 위치와 한 경로로 끝까지 간 뒤에 돌아갈 지점을 기억하기 위해서이다.** (이것은 함수 call 및 return 할때의 구조와 비슷하다고 보면 됨.)



**진행 과정**

![dfs1]('https://github.com/khm159/Python_study/blob/main/ProblemSolving/DFS/images/dfs01.png')

다음과 같은 노드가 존재할 때 1번 노드에서 탐색을 시작한다고 하자.

![dfs2]('https://github.com/khm159/Python_study/tree/main/ProblemSolving/DFS/images/dfs02.png')

**방문 처리된 노드**는 회색, **현재 처리하는 노드의 최상단 노드**는 파란색으로 표현시 

**시작(현재) 노드 1을 스택에 삽입.** 

**노드 1 방문 처리** 

![dfs3]('https://github.com/khm159/Python_study/tree/main/ProblemSolving/DFS/images/dfs03.png')

스택의 최상당 노드인 1에 연결된 노드는 2, 3, 8. 이중에서 방문하지 않은 노드는 2, 3, 8이다. 

<0> (**현재 스택의 최상단 요소 조회** --> 1)

<1> 현재 노드(1)에 연결된 노드 조회 

<2> 이중에서 방문하지 않은 노드(2, 3, 8)만 남김

<3> 방문하지 않은 노드가 있으므로 스택 pop 하지 않음

<4> 가장 첫번째 노드(2) 스택에 삽입

<5> 삽입된 노드(2) 방문 처리

![dfs4]('https://github.com/khm159/Python_study/tree/main/ProblemSolving/DFS/images/dfs04.png')

<0> (**현재 스택의 최상단 요소 조회** --> 2)

<1> 현재 노드(2)에 연결된 노드(7) 조회 

<2> 이중에서 방문하지 않은 노드(7)만 남김

<3> 방문하지 않은 노드가 있으므로 스택 pop 하지 않음

<4> 가장 첫번째 노드(7) 스택에 삽입

<5> 삽입된 노드(7) 방문 처리

![dfs5]('https://github.com/khm159/Python_study/tree/main/ProblemSolving/DFS/images/dfs05.png')

<0> (**현재 스택의 최상단 요소 조회** --> 7)

<1> 현재 노드(7)에 연결된 노드(6, 8) 조회 

<2> 이중에서 방문하지 않은 노드(6, 8)만 남김

<3> 방문하지 않은 노드가 있으므로 스택 pop 하지 않음

<4> 가장 첫번째 노드(6) 스택에 삽입

<5> 삽입된 노드 (6) 방문 처리

![dfs6]('https://github.com/khm159/Python_study/tree/main/ProblemSolving/DFS/images/dfs06.png')

<1> 현재 노드(6)에 연결된 노드() 조회

<2> **연결된 노드 없음.** 스택 pop (6번 노드)

    **스택 pop을 함 으로써 이전 위치로 돌아간다.**

















